import React, { useRef, useState, useEffect, Suspense } from 'react'
import { Canvas, useThree } from '@react-three/fiber'
import { OrbitControls, TransformControls, Grid, StatsGl } from '@react-three/drei'

const ELEMENT_COLORS = {
  H: '#ffffff', C: '#8c8c8c', N: '#3f51b5', O: '#e53935', P: '#ff9800', S: '#fbc02d',
  Cu: '#b87333', Ni: '#7f7f7f', Pt: '#d0d0e0'
}
const ELEMENT_RADII = { H: 0.25, C: 0.35, N: 0.33, O: 0.32, P: 0.4, S: 0.4, Cu: 0.6, Ni: 0.58, Pt: 0.62 }

function parseXYZ(xyzText) {
  try {
    const lines = xyzText.trim().split(/\r?\n/)
    let start = 0
    const maybeCount = parseInt(lines[0], 10)
    if (!Number.isNaN(maybeCount) && maybeCount > 0) start = 2
    const atoms = []
    let id = 1
    for (let i = start; i < lines.length; i++) {
      const l = lines[i].trim()
      if (!l) continue
      const [elem, xs, ys, zs] = l.split(/\s+/)
      const x = parseFloat(xs), y = parseFloat(ys), z = parseFloat(zs)
      if ([x, y, z].some((v) => Number.isNaN(v))) continue
      atoms.push({ id: id++, element: elem, pos: [x, y, z], color: ELEMENT_COLORS[elem] || '#9e9e9e' })
    }
    return atoms
  } catch {
    return []
  }
}

function toXYZ(atoms) {
  const lines = [String(atoms.length), 'Generated by Atomic Painter']
  for (const a of atoms) {
    const [x, y, z] = a.pos
    lines.push(`${a.element} ${x.toFixed(6)} ${y.toFixed(6)} ${z.toFixed(6)}`)
  }
  return lines.join('\n')
}

function makeSupercell(atoms, a1, a2, a3, nx, ny, nz) {
  const out = []
  let id = 1
  for (let i = 0; i < nx; i++) {
    for (let j = 0; j < ny; j++) {
      for (let k = 0; k < nz; k++) {
        const shift = [ i*a1[0] + j*a2[0] + k*a3[0], i*a1[1] + j*a2[1] + k*a3[1], i*a1[2] + j*a2[2] + k*a3[2] ]
        for (const a of atoms) {
          out.push({ id: id++, element: a.element, pos: [a.pos[0]+shift[0], a.pos[1]+shift[1], a.pos[2]+shift[2]], color: a.color })
        }
      }
    }
  }
  return out
}

function AtomMesh({ atom, selected, onPointerDown }) {
  const radius = ELEMENT_RADII[atom.element] || 0.4
  return (
    <mesh position={atom.pos} onPointerDown={(e) => { e.stopPropagation(); onPointerDown(atom.id) }}>
      <sphereGeometry args={[radius, 24, 24]} />
      <meshStandardMaterial color={selected ? '#00e5ff' : atom.color} metalness={0.1} roughness={0.4} />
    </mesh>
  )
}

function Atoms({ atoms, selectedId, setSelectedId, attachTransform }) {
  const groupRef = useRef()
  const { } = useThree()

  useEffect(() => {
    if (!attachTransform.current || !groupRef.current) return
    const obj = groupRef.current.children.find((c) => c.userData && c.userData.atomId === selectedId)
    if (obj) attachTransform.current.attach(obj)
  }, [selectedId, atoms])

  return (
    <group ref={groupRef}>
      {atoms.map((a) => (
        <group key={a.id} position={a.pos} userData={{ atomId: a.id }}>
          <AtomMesh atom={a} selected={selectedId === a.id} onPointerDown={(id) => setSelectedId(id)} />
        </group>
      ))}
    </group>
  )
}

function Lights() {
  return (
    <>
      <ambientLight intensity={0.6} />
      <directionalLight position={[5, 10, 5]} intensity={0.8} />
      <directionalLight position={[-5, -5, -5]} intensity={0.3} />
    </>
  )
}

function Scene({ atoms, setAtoms, selectedId, setSelectedId, gizmoMode, setGizmoMode }) {
  const transformRef = useRef()

  useEffect(() => {
    const t = transformRef.current
    if (!t) return
    const onChange = () => {
      const obj = t.object
      if (!obj) return
      const id = obj.userData.atomId
      setAtoms((prev) => prev.map((a) => (a.id === id ? { ...a, pos: [obj.position.x, obj.position.y, obj.position.z] } : a)))
    }
    t.addEventListener('objectChange', onChange)
    return () => void t.removeEventListener('objectChange', onChange)
  }, [setAtoms])

  useEffect(() => {
    const onKey = (e) => {
      if (e.key === 'Escape') setSelectedId(null)
      if (e.key.toLowerCase() === 'g') setGizmoMode((m) => (m === 'translate' ? 'rotate' : m === 'rotate' ? 'scale' : 'translate'))
      if (e.key === 'Delete' && selectedId != null) {
        setAtoms((prev) => prev.filter((a) => a.id !== selectedId))
        setSelectedId(null)
      }
    }
    window.addEventListener('keydown', onKey)
    return () => window.removeEventListener('keydown', onKey)
  }, [selectedId, setAtoms, setSelectedId, setGizmoMode])

  return (
    <>
      <Grid infiniteGrid cellSize={1} sectionColor="white" sectionSize={10} fadeDistance={60} position={[0, -2, 0]} />
      <Lights />
      <Suspense fallback={null}>
        <Atoms atoms={atoms} selectedId={selectedId} setSelectedId={setSelectedId} attachTransform={transformRef} />
      </Suspense>
      <TransformControls ref={transformRef} mode={gizmoMode} showX showY showZ enabled={!!selectedId} />
      <OrbitControls makeDefault enablePan enableRotate enableZoom />
      <StatsGl />
    </>
  )
}

function Panel({ atoms, setAtoms, selectedId, setSelectedId, gizmoMode, setGizmoMode }) {
  const selected = atoms.find((a) => a.id === selectedId) || null
  const [xyzText, setXyzText] = useState('')
  const fileInputRef = useRef(null)
  const [nx, setNx] = useState(1), [ny, setNy] = useState(1), [nz, setNz] = useState(1)
  const [a1, setA1] = useState([3.615, 0, 0])
  const [a2, setA2] = useState([0, 3.615, 0])
  const [a3, setA3] = useState([0, 0, 3.615])

  const addAtom = () => {
    const id = atoms.length ? Math.max(...atoms.map((a) => a.id)) + 1 : 1
    setAtoms([...atoms, { id, element: 'P', pos: [0, 0, 0], color: ELEMENT_COLORS['P'] }])
    setSelectedId(id)
  }

  const changeColor = (c) => selected && setAtoms(atoms.map((a) => a.id === selected.id ? { ...a, color: c } : a))
  const changeElement = (elem) => selected && setAtoms(atoms.map((a) => a.id === selected.id ? { ...a, element: elem, color: ELEMENT_COLORS[elem] || a.color } : a))

  const loadXYZFromText = () => {
    const parsed = parseXYZ(xyzText)
    if (parsed.length) setAtoms(parsed)
  }
  const exportXYZToDisk = async () => {
    const content = toXYZ(atoms)
    if (window.api?.saveXYZ) {
      await window.api.saveXYZ(content)
      return
    }

    const blob = new Blob([content], { type: 'text/plain' })
    const url = URL.createObjectURL(blob)
    const link = document.createElement('a')
    link.href = url
    link.download = 'structure.xyz'
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
    URL.revokeObjectURL(url)
  }
  const openXYZFromDisk = async () => {
    if (window.api?.openXYZ) {
      const res = await window.api.openXYZ()
      if (res?.ok) {
        setXyzText(res.content)
        const parsed = parseXYZ(res.content)
        if (parsed.length) setAtoms(parsed)
      }
      return
    }

    fileInputRef.current?.click()
  }

  const onFileInputChange = (event) => {
    const file = event.target.files?.[0]
    if (!file) return

    const reader = new FileReader()
    reader.onload = () => {
      const text = typeof reader.result === 'string' ? reader.result : ''
      setXyzText(text)
      const parsed = parseXYZ(text)
      if (parsed.length) setAtoms(parsed)
    }
    reader.readAsText(file)
    event.target.value = ''
  }

  const buildSupercell = () => {
    const A1 = a1.map(Number), A2 = a2.map(Number), A3 = a3.map(Number)
    const nxN = Math.max(1, Number(nx)|0), nyN = Math.max(1, Number(ny)|0), nzN = Math.max(1, Number(nz)|0)
    const replicated = makeSupercell(atoms, A1, A2, A3, nxN, nyN, nzN)
    setAtoms(replicated.map((a, idx) => ({ ...a, id: idx + 1 })))
    setSelectedId(null)
  }

  return (
    <div className="panel">
      <div className="section">
        <h3>Selection</h3>
        {selected ? (
          <div className="small">
            <div>ID: {selected.id}</div>
            <div className="row">
              <label className="k">Element</label>
              <select value={selected.element} onChange={(e) => changeElement(e.target.value)}>
                {Object.keys(ELEMENT_COLORS).map((el) => <option key={el} value={el}>{el}</option>)}
              </select>
            </div>
            <div className="row">
              <label className="k">Color</label>
              <input className="color-input" type="color" value={selected.color} onChange={(e) => changeColor(e.target.value)} />
            </div>
            <div>Pos: {selected.pos.map((v) => v.toFixed(3)).join(', ')}</div>
          </div>
        ) : (
          <div className="small">No atom selected.</div>
        )}
        <div className="row" style={{ marginTop: 8 }}>
          <button className="primary" onClick={addAtom}>+ Add P atom</button>
          <button onClick={() => setGizmoMode(m => m === 'translate' ? 'rotate' : m === 'rotate' ? 'scale' : 'translate')}>Gizmo: {gizmoMode}</button>
        </div>
        <div className="small" style={{ marginTop: 6 }}>Shortcuts: G = cycle gizmo • Delete = remove • Esc = clear</div>
      </div>

      <div className="section">
        <h3>Import / Export (.xyz)</h3>
        <input
          ref={fileInputRef}
          type="file"
          accept=".xyz,.txt"
          style={{ display: 'none' }}
          onChange={onFileInputChange}
        />
        <div className="row" style={{ gap: 6, marginBottom: 6 }}>
          <button onClick={openXYZFromDisk}>Open .xyz…</button>
          <button onClick={exportXYZToDisk}>Save .xyz…</button>
        </div>
        <textarea rows={8} style={{ width: '100%' }} value={xyzText} onChange={(e) => setXyzText(e.target.value)} placeholder={`Paste XYZ here (with or without header). Example:\n4\ncomment\nCu 0 0 0\nCu 1.8 1.8 0\nCu 1.8 0 1.8\nCu 0 1.8 1.8`} />
        <div className="row" style={{ gap: 6, marginTop: 6 }}>
          <button className="primary" onClick={loadXYZFromText}>Load from text</button>
        </div>
      </div>

      <div className="section">
        <h3>Supercell</h3>
        <div className="small">Lattice vectors (Å) & replication.</div>
        <label className="k">a1</label>
        <div className="grid3">
          {a1.map((v, i) => <input key={`a1${i}`} type="text" value={v} onChange={(e) => setA1(a1.map((x, j) => j === i ? Number(e.target.value) : x))} />)}
        </div>
        <label className="k">a2</label>
        <div className="grid3">
          {a2.map((v, i) => <input key={`a2${i}`} type="text" value={v} onChange={(e) => setA2(a2.map((x, j) => j === i ? Number(e.target.value) : x))} />)}
        </div>
        <label className="k">a3</label>
        <div className="grid3">
          {a3.map((v, i) => <input key={`a3${i}`} type="text" value={v} onChange={(e) => setA3(a3.map((x, j) => j === i ? Number(e.target.value) : x))} />)}
        </div>
        <div className="row" style={{ marginTop: 8 }}>
          <label className="k">nx</label><input type="text" value={nx} onChange={(e) => setNx(e.target.value)} style={{ width: 60 }} />
          <label className="k">ny</label><input type="text" value={ny} onChange={(e) => setNy(e.target.value)} style={{ width: 60 }} />
          <label className="k">nz</label><input type="text" value={nz} onChange={(e) => setNz(e.target.value)} style={{ width: 60 }} />
        </div>
        <button className="primary" style={{ marginTop: 8 }} onClick={buildSupercell}>Build supercell</button>
      </div>

      <div className="small">Roadmap: POSCAR/CIF/XSF I/O • stepped-surface generators (Cu(513), Ni(111)) • select by height/element/CN • snapping & symmetry • instancing for 10k+ atoms • undo/redo.</div>
    </div>
  )
}

function defaultAtoms() {
  const a = 1.8
  const base = [
    { el: 'Cu', p: [0, 0, 0] },
    { el: 'Cu', p: [a, a, 0] },
    { el: 'Cu', p: [a, 0, a] },
    { el: 'Cu', p: [0, a, a] }
  ]
  return base.map((b, i) => ({ id: i + 1, element: b.el, pos: b.p, color: ELEMENT_COLORS[b.el] }))
}

export default function App() {
  const [atoms, setAtoms] = useState(defaultAtoms())
  const [selectedId, setSelectedId] = useState(null)
  const [gizmoMode, setGizmoMode] = useState('translate')

  return (
    <div className="app">
      <div className="stage">
        <Canvas camera={{ position: [6, 6, 6], fov: 50 }} shadows>
          <color attach="background" args={["#0b1020"]} />
          <Scene
            atoms={atoms}
            setAtoms={setAtoms}
            selectedId={selectedId}
            setSelectedId={setSelectedId}
            gizmoMode={gizmoMode}
            setGizmoMode={setGizmoMode}
          />
        </Canvas>
        <div className="hint">LMB select • G gizmo • Delete remove • Esc clear</div>
      </div>
      <Panel
        atoms={atoms}
        setAtoms={setAtoms}
        selectedId={selectedId}
        setSelectedId={setSelectedId}
        gizmoMode={gizmoMode}
        setGizmoMode={setGizmoMode}
      />
    </div>
  )
}
